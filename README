
aspreify - reify answer set programs

The purpose of this program is to parse textual answer set programs
(ASP, Prolog like syntax) as accepted by lparse
(http://www.tcs.hut.fi/Software/smodels/) and produce a description of
the input program as ASP facts, effectively reifying the input program
allowing, among other things, ASP programs to be interpreted or
modified by other ASP programs.

Vesa Luukkala (vesa.luukkala@gmail.com), 29.11.2012 

1. Building 

Requires Haskell platform (http://www.haskell.org/platform/), tested on 2012.2.0.0. 
To produce an executable:
> ghc -o aspreify main.hs rdfrender.hs txtrender.hs factrender.hs aspparse.hs dereify.hs

Obtain the sources initially:
> git clone git://www.github.com/vluukkal/aspreify

Update later on after initially fetching them: 
> git remote update

A simple test:
> ./aspreify tests/hamiltonian_cycle.lp
produces tests/hamiltonian_cycle.lp.reified 

> ./aspreify -t tests/hamiltonian_cycle.lp
The result has the same unreified rules as the input, used for testing.
tests/hamiltonian_cycle.lp.lp

> ./aspreify -r tests/hamiltonian_cycle.lp
The result is and RDF/N3-like format. 
tests/hamiltonian_cycle.lp.ssls
 
2. Limitations 

2.1 Error handling 

Error handling is rudimentary, syntax errors are reported, but often
indicated to be after the actual error. Errors are not signaled with the
return values, but the result file contains the syntax error.

2.2 Non-supported syntax 

All of the examples in lparse distribution examples/ directory are parsed. 

All syntax should be parsed, but at this version only the -t option 
will render the following declarations, default and -r will ignore them
in the result: 
- maximize, minimize, compute, function, external, show, hide 
- #show, #hide

Sometimes the hashed primitives will be converted back to nonhashed
ones, e.g. #mod -> mod. 

At times the parser may be more liberal than the lparse one,
e.g. minimize { a(X), b(Y) } will be accepted. 

3. Self tests 

Compile the parser test suite and run it:
> ghc -o runparsertests testaspparse.hs aspparse.hs 
> ./runparsertests 

4. Use cases 

The directory metaeval/ contains some example programs to show potential
applications for reification. 

4.1 Metaevaluation 

metaeval/simple_variable_free.lp contains a simplistic program with no variables
and metaeval/meta.lp contains a metaevaluator for variable-free answer set programs. 

1. Reify the program: ./aspreify metaeval/simple_variable_free.lp
   to produce metaeval/simple_variable_free.lp.reified 
2. Combine the metaevaluator with the reified program: 
   cat metaeval/meta.lp metaeval/simple_variable_free.lp.reified > metaeval/x.lp
3. Calculate the answer sets: gringo metaeval/x.lp | clasp -n 0 
   Compare this with direct evaluation: lparse metaeval/simple_variable_free.lp | smodels 0
   Or with gringo metaeval/x.lp | clasp -n 0 

4.2 Metagrounding 

metaeval/hamilton.lp contains an answer set program with variables and metaeval/metaground.lp 
contains a metagrounder. 

1. Reify the program: ./aspreify metaeval/hamilton.lp
   to produce metaeval/hamilton.lp.reified 
2. Combine the metagrounder with the reified program: 
   cat metaeval/metaground.lp metaeval/hamilton.lp.reified > metaeval/y.lp
3. Calculate the answer sets: gringo metaeval/y.lp | clasp -n 0 
   with 63 answer sets, realassign/3 contains the variable assignments. 

5. Other

The toviz.py program reads in the reified program and generates a
graphviz graph out of it. 

6. TODO

TODO
- List the produced factnames and the documentation for them
- add full rendering of all directives of the lparse/gringo language
- have a look at quickcheck  


#EOF


