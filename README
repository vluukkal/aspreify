
aspreify - reify answer set programs

The purpose of this program is to parse textual answer set programs
(ASP, Prolog like syntax) as accepted by lparse
(http://www.tcs.hut.fi/Software/smodels/) and produce a description of
the input program as ASP facts, effectively reifying the input program
allowing, among other things, ASP programs to be interpreted or
modified by other ASP programs. The reified format can be converted back 
to plain rules. 

Decomposing the the rules to facts enables the evaluator to
reason over and maintain the provenance of the source information as
well as the rules themselves, which is important in distributed
reasoning.

An evaluator in ASP, a metaevaluator, allows specifying the semantics 
of the ASP evaluation within the same ASP framework. 
An ASP metaevaluator for reified variable free ASP programs is provided,
the variabled case is under construction, but emerging, starting with a
metagrounder supporting variables.  

For more elaboration: 
@inproceedings{DBLP:conf/rr/JanhunenL12,
  author    = {Tomi Janhunen and
               Vesa Luukkala},
  title     = {Meta Programming with Answer Sets for Smart Spaces},
  booktitle = {RR},
  year      = {2012},
  pages     = {106-121},
  ee        = {http://dx.doi.org/10.1007/978-3-642-33203-6_9}
}

Vesa Luukkala (vesa.luukkala@gmail.com), 18.11.2013

1. Building 

Requires Haskell platform (http://www.haskell.org/platform/), tested on 2012.2.0.0. 
To produce an executable:
> ghc -O2 -o aspreify main.hs rdfrender.hs txtrender.hs factrender.hs aspparse.hs dereify.hs

Alternatively, to enable RTS options to execute with large stack sizes
> ghc -rtsopts -O2 -o aspreify main.hs rdfrender.hs txtrender.hs factrender.hs aspparse.hs dereify.hs

Obtain the sources initially:
> git clone -b propproject git://www.github.com/vluukkal/aspreify

Update later on after initially fetching them: 
> git pull

2. Use cases 

The directory metaeval/ contains some example programs to show potential
applications for reification. 

2.1 Metaevaluation 

metaeval/simple_variable_free.lp contains a simplistic program with no variables
and metaeval/meta.lp contains a metaevaluator for variable-free answer set programs. 

1. Reify the program: ./aspreify metaeval/simple_variable_free.lp
   to produce metaeval/simple_variable_free.lp.reified 
2. Combine the metaevaluator with the reified program: 
   cat metaeval/meta.lp metaeval/simple_variable_free.lp.reified > metaeval/x.lp
3. Calculate the answer sets: gringo metaeval/x.lp | clasp -n 0 
   Compare this with direct evaluation: 
   lparse metaeval/simple_variable_free.lp | smodels 0
   Or with 
   gringo metaeval/x.lp | clasp -n 0 

2.2 Metagrounding 

A quick test of metagrounding with timing information:
0. cd metaeval/
1. Run the grounding for the example with timing information:
   ./timedground.sh timed_hamilton_toground.lp.reified 
   which will produce a directory 'timed_hamilton_toground$date_$time'
2. The result is available in: 
   timed_hamilton_toground$date_$time/output/smres1.lp.ground
   
Note that you may need to set the paths for aspreify and the metagrounder 
in provground.sh to fit your system and installation using -m and -a flags. 


2.3 Examples

Some simple examples highlighting particular features of aspreify:

> ./aspreify tests/hamiltonian_cycle.lp
produces tests/hamiltonian_cycle.lp.reified 

> ./aspreify -t tests/hamiltonian_cycle.lp
The result has the same unreified rules as the input, used for testing.
Produced to 
tests/hamiltonian_cycle.lp.lp

> ./aspreify -r tests/hamiltonian_cycle.lp
The reified result is RDF/N3-like format produced to 
tests/hamiltonian_cycle.lp.ssls

> ./aspreify -d tests/uncle.lp.reified 
The result is corresponding set of dereified rules produced to 
tests/uncle.lp.reified.dereified  

> ./aspreify -g tests/hamiltonian_cycle.lp.reified 
The result is corresponding set of dereified and ground rules 
produced to 
tests/hamiltonian_cycle.lp.reified.ground
Only ground rules are produced, other rules (with variables) are ignored. 

An earlier version of grounding using variable bindings, left here for
posterity: 

> ./ground.sh tests/uncle3.lp 
produces tests/uncle3.lp.reified.res


Run with increased stack size:
> ./aspreify +RTS -K128M -RTS -d tests/uncle.lp.reified

3. Limitations 

3.1 Error handling 

Error handling is rudimentary, syntax errors are reported, but often
indicated to be after the actual error. Errors are not signaled with the
return values, but the result file contains the syntax error.

3.2 Issues in input syntax

All of the examples in lparse distribution examples/ directory are parsed. 

All syntax should be parsed, but at this version only the -t option 
will render the following declarations, default and -r will ignore them
in the result: 
- maximize, minimize, compute, function, external, show, hide 
- #show, #hide

Sometimes the hashed primitives will be converted back to nonhashed
ones, e.g. #mod -> mod. 

At times the parser may be more liberal than the lparse one,
e.g. minimize { a(X), b(Y) } will be accepted. 

The dereifier and grounder do not yet support the following syntactical 
constructs:
- weighted statments
- choice statements
- full expressions 
- maximize, minimize, compute, function, external, show, hide 
- #show, #hide

4. Self tests 

Compile the parser test suite and run it:
> ghc -o runparsertests testaspparse.hs aspparse.hs 
> ./runparsertests 

Run the grounding tests:
> cd tests
> for i in ground_input/*; do ./rungroundtest.sh $i; done 


5. Other

smodelsres.py program reads in the resulting answer set and converts
them to facts ands saves individual files with filenames corresponding
to the number of the answer set. 

The toviz.py program reads in the reified program and generates a
graphviz graph out of it. 


6. TODO

TODO
- List the produced factnames and the documentation for them
- add full rendering of all directives of the lparse/gringo language
- have a look at quickcheck  


#EOF


